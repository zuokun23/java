# 01
- 程序的耦合：程序间的依赖关系
  - 包括 类之间的依赖、方法间的依赖
- 程序的解耦：降低程序间的依赖关系
  - 实际开发中：编译器不依赖，运行期间依赖
  - 解耦的思路：
    - 第一步：使用反射来创建对象，避免使用new关键字
    - 第二步：通过读取配置文件，来获取要创建的对象全限定类名
# 02
- 一个创建Bean对象的工厂
   - Bean:在计算机中，有可重用组件的含义
   - JavaBean:用java语言编写的可重用组件
    - javabean > 实体类
    - 它就是创建我们的service和dao对象的。
    - 第一个：需要一个配置文件来配置我们的service和dao
      - 配置的内容：唯一标识=全限定类名（key=value）
    - 第二个：通过读取配置文件中内容，反射创建对象
    - 我的配置文件可以是xml也可以是properties(此处用properties因为更简单)
# 02 改进：加入单例模式
# 03 
- 获取spring的ioc核心容器，并根据id获取对象
  - ApplicationContext的三个常用实现类：
     - lassPathXmlApplicationContext:它可以加载路径下的配置文件，要求配置文件必须在类路径下。不在的话，加载不了。
     - FileSystemXmlApplicationContext：它可以加载磁盘任意路径下的配置文件（必须有访问权限）
     - AnnotationConfigApplicationContext：它用于读取注解配置创建容器
  - 核心容器的两个接口引发出的问题：
     - ApplicationContext:
       - 单例对象适用时（总共只有一个实例，不如早创建）
          - (它在构建核心容器时，创建对象采取的策略是立即加载的方式。也就是说，只要一读取完配置文件马上就创建文件中配置的对象。）
       - 多例对象时采用延迟加载
       - 这个接口非常智能，所有选择这个
     - BeanFactory:
        - 多例对象适用
         -（反正对象次数不限定，加载xml实例一个没有必要）
         -（它在创建核心容器时，创建对象采取的策略是延迟加载的方式。
           也就是说，什么时候根据id获取对象了，什么时候才真正的创建对象。）
# 04           
- ## 1.创建bean的三种方式
  - [x] 第一种方式：使用默认的构造函数：在spring的配置文件中使用bean标签，使用id和class属性，且没有其他属性和标签时。此时类中没有默认构造函数，则对象无法创建。
    - java中如果在一个类中没有写明任何构造函数的,那么会存在一个无参的构造函数。
    - 但如果写明了一个有参的构造函数,那么无参的构造函数就不复存在了。
  - [x] 第二种方式：使用工厂中的普通方法创建对象，使用某个类中的方法创建对象，并存入spring容器
    - 模拟一个工厂类，该类可能存在于jar包中的，以class而不是java方式呈现。
    - 我们无法通过修改源码的方式提供构造函数。
  - [x] 第三种方式：使用工厂中的静态方法创建对象，使用某个类中的静态方法创建对象，并存入spring容器
    - 模拟一个工厂类，该类可能存在于jar包中的，以class而不是java方式呈现。
    - 我们无法通过修改源码的方式提供构造函数。   
- ## 2.bean对象的作用范围
  
- ## 3.bean对象的生命周期
